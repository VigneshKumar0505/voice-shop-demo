<!doctype html>
<html lang="en">
<head>
  <!-- SECTION: META & THEME -------------------------------------------------->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Shop ‚Äî Telecom Assistant (Neural TTS + Whisper STT)</title>
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --fg:#e2e8f0; --muted:#94a3b8; --accent:#22c55e; --warn:#ef4444; --line:#1f2937; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--fg)}
    .wrap{max-width:980px;margin:32px auto;padding:20px}
    h1{font-size:1.5rem;margin:0 0 12px}
    .card{background:#111827aa;border:1px solid var(--line);border-radius:14px;padding:16px;margin:12px 0}
    button{border:0;border-radius:999px;padding:10px 16px;font-weight:700;cursor:pointer}
    .mic{background:var(--accent);color:#08210f}
    .mic.stop{background:var(--warn);color:#fff}
    .status{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--panel);border:1px solid var(--line);color:var(--muted);margin-left:8px}
    .status.online{color:var(--accent);border-color:#14532d}
    .status.offline{color:var(--warn);border-color:#3f1d1d}
    .area{min-height:54px;padding:12px;border-radius:10px;background:var(--panel);border:1px dashed #334155}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .prod{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
    .title{font-weight:700}
    .price{color:#cbd5e1;margin-left:6px}
    .caps{font-size:.75rem;color:#94a3b8;text-transform:uppercase;letter-spacing:.06em}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .cart{position:sticky;top:16px}
    code{background:#0b1220;border:1px solid var(--line);padding:2px 6px;border-radius:6px;color:#cbd5e1}
    .seg{display:inline-flex;border:1px solid var(--line);border-radius:999px;overflow:hidden;margin-left:auto}
    .seg button{background:transparent;color:#cbd5e1;border-right:1px solid var(--line)}
    .seg button:last-child{border-right:0}
    .seg button.active{background:#0b1220}
  </style>

  <!-- SECTION: LIBS (Transformers.js for Whisper) ----------------------------->
  <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.1"></script>

  <!-- SECTION: TTS (Neural ‚Äì Kokoro) ‚Äì ESM LOADER ---------------------------->
  <!-- Keep this as a separate <script type="module"> so you can swap models easily -->
  <script type="module" id="kokoro-loader">
    import { KokoroTTS } from "https://cdn.jsdelivr.net/npm/kokoro-js@1.2.1/+esm";

    // === CONFIG you may tweak later =========================================
    const MODEL_ID = "onnx-community/Kokoro-82M-v1.0-ONNX"; // ONNX model
    const DTYPE    = "q8";                                   // fp32/fp16/q8/q4/q4f16
    const VOICE_ID = "af_sky";                               // other examples: af_nicole, am_miki
    // =========================================================================

    const state = { tts:null, ready:false, loading:false };

    async function ensureKokoro() {
      if (state.ready || state.loading) return;
      state.loading = true;
      window.dispatchEvent(new CustomEvent("kokoro-status",{detail:{status:"loading"}}));
      try {
        state.tts = await KokoroTTS.from_pretrained(MODEL_ID, { dtype: DTYPE });
        state.ready = true;
        window.dispatchEvent(new CustomEvent("kokoro-status",{detail:{status:"ready"}}));
      } catch (e) {
        console.error(e);
        window.dispatchEvent(new CustomEvent("kokoro-status",{detail:{status:"error",error:String(e)}}));
      } finally { state.loading = false; }
    }

    async function speakKokoro(text) {
      try {
        await ensureKokoro();
        if (!state.ready) throw new Error("Kokoro not ready");
        const audio = await state.tts.generate(text, { voice: VOICE_ID });
        const wavBuffer = audio.toWav(); // ArrayBuffer (24 kHz, mono)
        const url = URL.createObjectURL(new Blob([wavBuffer],{type:"audio/wav"}));
        const a = new Audio(url);
        a.onended = () => URL.revokeObjectURL(url);
        await a.play();
        return true;
      } catch (err) {
        console.warn("Kokoro fallback:", err);
        return false;
      }
    }

    // Expose small bridge for non-module scripts
    window.__kokoro = { ensureKokoro, speakKokoro, state };
  </script>
</head>
<body>
  <!-- SECTION: HEADER / CONTROLS --------------------------------------------->
  <div class="wrap">
    <h1>üéôÔ∏è Voice Shop ‚Äî Telecom Assistant
      <span id="kokoroBadge" class="status">TTS: browser voice</span>
      <span id="whisperBadge" class="status">STT: Browser</span>
    </h1>

    <div class="card">
      <div class="row">
        <button id="toggle" class="mic">Start Listening</button>
        <span id="live" class="status offline">Mic: idle</span>
        <span id="secure" class="status">Secure context: ‚Ä¶</span>
        <div class="seg">
          <button id="modeWeb" class="active" title="Browser Web Speech API">Browser STT</button>
          <button id="modeWhisper" title="Whisper STT (better accuracy)">Whisper STT</button>
        </div>
      </div>
      <p style="margin:8px 0 0;color:#cbd5e1">
        Try: <code>show sd wan</code> ¬∑ <code>find routers under three thousand</code> ¬∑
        <code>find broadband 300 mbps</code> ¬∑ <code>add sd wan pro to cart</code> ¬∑ <code>add the second to cart</code> ¬∑ <code>what's in my cart</code>
      </p>
      <p id="modelHint" style="margin:6px 0 0;color:#94a3b8;font-size:.9rem">
        Mode: <b>Browser STT</b> (fast). Switch to <b>Whisper STT</b> for better accuracy on telecom terms.
      </p>
    </div>

    <!-- SECTION: CONSOLE (USER / ASSISTANT) ---------------------------------->
    <div class="card">
      <div class="row">
        <div style="flex:1">
          <div class="caps">You said</div>
          <div id="you" class="area" aria-live="polite"></div>
        </div>
        <div style="flex:1">
          <div class="caps">Assistant replied</div>
          <div id="bot" class="area" aria-live="polite"></div>
        </div>
      </div>
    </div>

    <!-- SECTION: RESULTS + CART --------------------------------------------->
    <div class="row" style="align-items:flex-start">
      <div style="flex:2" class="card">
        <div class="row" style="justify-content:space-between">
          <div class="caps">Results</div>
          <div id="count" class="status">0 items</div>
        </div>
        <div id="results" class="grid"></div>
      </div>

      <div style="flex:1;min-width:280px" class="card cart">
        <div class="caps">Cart</div>
        <div id="cartList" class="area" style="min-height:120px"></div>
        <div class="row" style="margin-top:8px">
          <div id="cartTotal" class="status">Total: ‚Çπ0</div>
          <button id="btnCheckout">Checkout</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION: APP SCRIPT (EVERYTHING BELOW IS SWAPPABLE BY SECTION) -------->
  <script>
    // ===== SECTION: GLOBAL STATE & DOM HOOKS =================================
    let PRODUCTS = [];
    let RESULTS = [];
    const CART = [];
    let mode = 'web'; // 'web' | 'whisper'

    const you = document.getElementById('you');
    const bot = document.getElementById('bot');
    const live = document.getElementById('live');
    const secure = document.getElementById('secure');
    const toggleBtn = document.getElementById('toggle');
    const resultsEl = document.getElementById('results');
    const countEl = document.getElementById('count');
    const cartList = document.getElementById('cartList');
    const cartTotal = document.getElementById('cartTotal');
    const btnCheckout = document.getElementById('btnCheckout');
    const modeWebBtn = document.getElementById('modeWeb');
    const modeWhisperBtn = document.getElementById('modeWhisper');
    const modelHint = document.getElementById('modelHint');
    const kokoroBadge = document.getElementById('kokoroBadge');
    const whisperBadge = document.getElementById('whisperBadge');

    secure.textContent = 'Secure context: ' + (window.isSecureContext ? 'yes' : 'no');

    // ===== SECTION: BADGE HELPERS (UI feedback) ==============================
    function setKokoroBadge(text, online=false){
      kokoroBadge.textContent = text;
      kokoroBadge.classList.toggle('online', online);
    }
    function setWhisperBadge(text, online=false){
      whisperBadge.textContent = text;
      whisperBadge.classList.toggle('online', online);
    }
    // React to Kokoro loader events
    window.addEventListener('kokoro-status', (e)=>{
      const s = e.detail?.status;
      if (s === 'loading') setKokoroBadge('TTS: loading neural voice‚Ä¶', true);
      else if (s === 'ready') setKokoroBadge('TTS: neural (Kokoro)', true);
      else setKokoroBadge('TTS: browser voice', false);
    });

    // ===== SECTION: PRODUCTS (fetch + render) ================================
    async function loadProducts(){
      const res = await fetch('products.json', { cache: 'no-store' });
      PRODUCTS = await res.json();
      RESULTS = PRODUCTS.slice(0, 6);
      renderResults(RESULTS);
    }

    function renderResults(list){
      resultsEl.innerHTML = '';
      countEl.textContent = `${list.length} item${list.length!==1?'s':''}`;
      list.forEach((p, idx) => {
        const el = document.createElement('div');
        el.className = 'prod';
        el.innerHTML = `
          <div class="title">${idx+1}. ${p.title}</div>
          <div class="caps">${p.category} ¬∑ ${p.brand}${p.sku?` ¬∑ ${p.sku}`:''}</div>
          <div style="margin:6px 0">
            <span class="price">‚Çπ${p.price}</span>
            ${p.speed_mbps ? `<span class="status">${p.speed_mbps} Mbps</span>` : ''}
            ${p.contract ? `<span class="status">${p.contract}</span>` : ''}
          </div>
          <ul style="margin:6px 0 10px 18px; color:#cbd5e1">
            ${(p.features||[]).slice(0,3).map(f=>`<li>${f}</li>`).join('')}
          </ul>
          <button data-idx="${idx}" class="mic">Add to cart</button>
        `;
        resultsEl.appendChild(el);
      });
      document.querySelectorAll('[data-idx]').forEach(b=>{
        b.onclick = (e)=> addToCart(list[parseInt(e.currentTarget.dataset.idx,10)]);
      });
    }

    // ===== SECTION: CART (state + render) ====================================
    function renderCart(){
      if (!CART.length){
        cartList.textContent = 'Cart is empty.';
        cartTotal.textContent = 'Total: ‚Çπ0';
        return;
      }
      cartList.innerHTML = CART.map((c,i)=>`${i+1}. ${c.title} ‚Äî ‚Çπ${c.price}`).join('<br>');
      const total = CART.reduce((s,p)=>s+p.price,0);
      cartTotal.textContent = `Total: ‚Çπ${total}`;
    }
    function addToCart(p){
      CART.push(p);
      speak(`Added ${p.title} for ‚Çπ${p.price} to your cart.`);
      renderCart();
    }
    btnCheckout.onclick = ()=>{
      if (!CART.length){ speak('Your cart is empty.'); return; }
      const total = CART.reduce((s,p)=>s+p.price,0);
      speak(`You have ${CART.length} item${CART.length>1?'s':''} for a total of ‚Çπ${total}. Ready to place the order?`);
    };

    // ===== SECTION: TTS (Neural-first, browser fallback) =====================
    function pickVoice() {
      const VOICES = speechSynthesis.getVoices();
      return VOICES.find(v => /Google/.test(v.name) && /en-/.test(v.lang))
          || VOICES.find(v => /en-/.test(v.lang))
          || null;
    }
    async function speak(text){
      bot.textContent = text;
      // try neural TTS first
      if (window.__kokoro?.speakKokoro){
        const ok = await window.__kokoro.speakKokoro(text);
        if (ok) return;
      }
      // fallback to system voice
      const u = new SpeechSynthesisUtterance(text);
      const v = pickVoice();
      if (v) u.voice = v;
      u.lang = v?.lang || 'en-US';
      u.rate = 1.02; u.pitch = 1.05;
      speechSynthesis.cancel(); speechSynthesis.speak(u);
    }
    // Warm up Kokoro once (optional)
    (async ()=>{ try{ if (window.__kokoro) await window.__kokoro.ensureKokoro(); }catch{} })();

    // ===== SECTION: NLU HELPERS (normalize, numbers, fuzzy match) ============
    function editDistance(a,b){
      const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
      for (let i=0;i<=m;i++) dp[i][0]=i; for (let j=0;j<=n;j++) dp[0][j]=j;
      for (let i=1;i<=m;i++) for (let j=1;j<=n;j++){
        const cost=a[i-1]===b[j-1]?0:1;
        dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
      } return dp[m][n];
    }
    function normalize(raw){
      let t = (raw || '').toLowerCase();
      t = t
        .replace(/\bhd\s*ban\b/g, 'sdwan')
        .replace(/\bsd\s*one\b/g, 'sdwan')
        .replace(/\bes?tee\s*wan\b/g, 'sdwan')
        .replace(/\bsd\s*van\b/g, 'sdwan');
      t = t.replace(/[-_/.,]/g,' ').replace(/\s+/g,' ').trim();
      t = t.replace(/\bs\s*d\s*w\s*a\s*n\b/g,'sdwan')
           .replace(/\bsd\s*wan\b/g,'sdwan')
           .replace(/\bsdvan\b/g,'sdwan');
      t = t.replace(/\brouters?\b/g,'router').replace(/\bswitch(?:es)?\b/g,'switch');
      const tokens = t.split(' ');
      for (let i=0;i<tokens.length;i++){
        if (editDistance(tokens[i], 'sdwan') <= 1) tokens[i] = 'sdwan';
      }
      return tokens.join(' ');
    }
    const NUM_WORDS = {'zero':0,'one':1,'two':2,'three':3,'four':4,'five':5,'six':6,'seven':7,'eight':8,'nine':9,'ten':10,'eleven':11,'twelve':12,'thirteen':13,'fourteen':14,'fifteen':15,'sixteen':16,'seventeen':17,'eighteen':18,'nineteen':19,'twenty':20,'thirty':30,'forty':40,'fifty':50,'sixty':60,'seventy':70,'eighty':80,'ninety':90,'hundred':100,'thousand':1000};
    function wordsToNumber(phrase){
      const tokens = phrase.split(/\s+/); let total=0,current=0;
      for (const w of tokens){
        const n = NUM_WORDS[w]; if (n==null) continue;
        if (n===100 || n===1000){ current=(current||1)*n; if (n===1000){ total+=current; current=0; } }
        else current+=n;
      } return total+current;
    }
    function parsePrice(text){
      const d = /under\s+(\d[\d,]*)/.exec(text); if (d) return parseInt(d[1].replace(/,/g,''),10);
      const w = /under\s+([a-z\s-]+?)(?:\b(?:rupees|inr))?\b/.exec(text);
      if (w){ const val=wordsToNumber(w[1].replace(/-/g,' ')); if (val>0) return val; }
      return null;
    }
    const ORDINAL_WORDS = {'first':1,'second':2,'third':3,'fourth':4,'fifth':5,'sixth':6,'seventh':7,'eighth':8,'ninth':9,'tenth':10};
    function parseOrdinal(text){
      const m1 = /add the (\d+)(st|nd|rd|th)?/.exec(text); if (m1) return parseInt(m1[1],10);
      const m2 = /add the (first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth)/.exec(text); if (m2) return ORDINAL_WORDS[m2[1]];
      return null;
    }
    function detectCategory(text){
      if (/\bsdwan\b/.test(text)) return 'sdwan';
      if (/\bbroadband\b|\binternet\b|\bfiber\b|\bfibre\b/.test(text)) return 'broadband';
      if (/\brouter\b/.test(text)) return 'router';
      if (/\bswitch\b/.test(text)) return 'switch';
      if (/\biot\b|\bsensor\b|\bcamera\b/.test(text)) return 'iot';
      if (/\bsecurity\b|\bfirewall\b|\bsase\b|\bztna\b/.test(text)) return 'security';
      return null;
    }
    function tokenize(s){ return s.split(/\s+/).filter(Boolean); }
    function bestMatchProductFromText(text, list){
      const n = normalize(text); const tokens = tokenize(n);
      const hasPro=/\bpro\b|\bprofessional\b/.test(n), hasLite=/\blite\b|\blight\b/.test(n), hasPlus=/\bplus\b|\bmax\b/.test(n);

      // Direct variant pick
      const tagged = list.filter(p=>{
        const title=(p.title||'').toLowerCase(), sku=(p.sku||'').toLowerCase();
        const tPro = /\bpro\b/.test(title) || /-p\b/.test(sku);
        const tLite= /\blite\b/.test(title)|| /-l\b/.test(sku);
        const tPlus= /\bplus\b|\bmax\b/.test(title);
        return (hasPro&&tPro)||(hasLite&&tLite)||(hasPlus&&tPlus);
      });
      if (tagged.length===1) return tagged[0];
      if (tagged.length>1){
        if (hasPro) return tagged.find(p=>/\bpro\b/.test((p.title||'').toLowerCase()))||tagged[0];
        if (hasLite) return tagged.find(p=>/\blite\b/.test((p.title||'').toLowerCase()))||tagged[0];
        return tagged[0];
      }

      // Fuzzy fallback with bonuses/penalties
      let best=null,bestScore=-1;
      for (const p of list){
        const title=(p.title||'').toLowerCase(), brand=(p.brand||'').toLowerCase(), sku=(p.sku||'').toLowerCase();
        const words = new Set(title.replace(/[^a-z0-9 ]/g,' ').split(/\s+/).concat(brand.split(/\s+/),(p.category||'').split(/\s+/)).filter(Boolean));
        let score=0;
        if (sku && n.includes(sku)) score+=20;
        for (const t of tokens){ if (words.has(t)) score+=2; }
        if (hasPro && /\bpro\b/.test(title)) score+=10;
        if (hasLite&& /\blite\b/.test(title)) score+=10;
        if (hasPro && /\blite\b/.test(title)) score-=12;
        if (hasLite&& /\bpro\b/.test(title))  score-=12;
        const dist=editDistance(title.replace(/\s+/g,''), n.replace(/\s+/g,'')); score+=Math.max(0,5-dist);
        if (score>bestScore){ best=p; bestScore=score; }
      }
      return best;
    }

    // ===== SECTION: INTENT HANDLER (single entrypoint) =======================
    function handleUtterance(raw){
      const text = normalize(raw);
      you.textContent = raw;

      if (/what can you do|help/.test(text)){
        speak('I can find broadband, SD-WAN, routers, switches, IoT and security products, filter by price or speed, and add items to your cart.');
        return;
      }
      if (/what'?s in my cart|show cart|^cart$/.test(text)){
        if (!CART.length){ speak('Your cart is empty.'); return; }
        speak(`You have ${CART.length} item${CART.length>1?'s':''} totaling ‚Çπ${CART.reduce((s,p)=>s+p.price,0)}.`);
        return;
      }

      const nth = parseOrdinal(text);
      if (nth){ const i=nth-1; if (RESULTS[i]) { addToCart(RESULTS[i]); return; } }

      if (/add .* to cart|add to cart/.test(text)){
        const pmatch = bestMatchProductFromText(text, RESULTS.length?RESULTS:PRODUCTS);
        if (pmatch){ addToCart(pmatch); return; }
        if (RESULTS[0]) addToCart(RESULTS[0]); else speak('No results to add.');
        return;
      }

      if (/find|show|look for|browse/.test(text)){
        const category=detectCategory(text), priceCap=parsePrice(text), speed=(/(\d{2,4})\s*mbps/.exec(text)?.[1]|0);
        const brand=/(orangetel|orangebiz|orangesecure|netbee|switchly|sensehub)/.exec(text)?.[1]||null;
        let list=PRODUCTS.slice();
        if (category) list=list.filter(p=>p.category===category);
        if (priceCap!=null) list=list.filter(p=>p.price<=priceCap);
        if (speed) list=list.filter(p=>p.speed_mbps && p.speed_mbps>=Number(speed));
        if (brand) list=list.filter(p=>p.brand.toLowerCase()===brand);
        RESULTS=list;
        if (!list.length){ resultsEl.innerHTML=''; countEl.textContent='0 items'; speak('No matching products found.'); return; }
        renderResults(list);
        const first=list[0]; let summary=`${list.length} result${list.length>1?'s':''}`;
        if (category) summary+=` for ${category}`; if (priceCap!=null) summary+=` under ${priceCap} rupees`; if (speed) summary+=` at ${speed} megabits per second or more`;
        speak(`${summary}. First is ${first.title} at ‚Çπ${first.price}.`); return;
      }

      if (/stop|be quiet|silence/.test(text)){ speechSynthesis.cancel(); bot.textContent='‚èπÔ∏è Stopped speaking.'; return; }
      speak('Try: show sd-wan; find routers under three thousand; add sd wan pro to cart; add the second to cart; what‚Äôs in my cart.');
    }

    // ===== SECTION: STT ‚Äì Browser Web Speech API ============================
    const DOMAIN_WORDS = ['sdwan','broadband','internet','fiber','router','switch','iot','security','firewall','sase','ztna'];
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
    let rec, listening=false;
    if (SpeechRec){
      rec = new SpeechRec();
      rec.lang = 'en-IN';
      rec.maxAlternatives = 3;
      rec.continuous = false;
      rec.interimResults = true;
      rec.onresult = (event)=>{
        const firstAlt = event.results[0][0].transcript; you.textContent = firstAlt;
        if (event.results[0].isFinal){
          const alts=[]; for (const r of event.results){ for (let i=0;i<r.length;i++) alts.push(r[i].transcript); }
          let best=alts[0],score=-1; for (const a of alts){ const n=normalize(a); const hit=DOMAIN_WORDS.some(w=>n.includes(w)); if ((hit?1:0)>score){best=a;score=hit?1:0;} }
          handleUtterance(best);
        }
      };
      rec.onend = ()=>{ if (listening && mode==='web') try{rec.start()}catch{}; };
    }

        <!-- ===== SECTION: STT ‚Äì Whisper (Transformers.js) w/ badges, auto-stop ==== -->
    <script>
    // Keep using the existing whisperBadge + helpers already defined above.

    let mediaStream, mediaRecorder, chunks = [];
    let asr = null;
    let whisperReady = false;

    // Prefer tiny on first run (fastest), and try upgrading to base in background later.
    const WHISPER_FAST    = 'Xenova/whisper-tiny.en';
    const WHISPER_QUALITY = 'Xenova/whisper-base.en';

    // NOTE: Do NOT force dtype here. Let Transformers.js choose (WASM/WebGL/WebGPU).
    // For some browsers, forcing fp16 can cause init failures.

    async function ensureWhisper() {
      if (asr) { whisperReady = true; setWhisperBadge('STT: Whisper (ready)', true); return; }

      setWhisperBadge('STT: Whisper (loading‚Ä¶)');
      speak('Loading Whisper model, this may take a moment on first run.');

      // Show download progress (if provided by the backend)
      const progress_callback = (p) => {
        // p.status: 'progress' | 'done'; p.file, p.loaded, p.total
        if (p?.status === 'progress' && typeof p.loaded === 'number' && typeof p.total === 'number') {
          const pct = Math.max(0, Math.min(100, Math.round((p.loaded / Math.max(1, p.total)) * 100)));
          setWhisperBadge(`STT: Whisper (loading ${pct}%)`);
        }
      };

      // A resilient loader with retries/backoff
      const loadPipeline = async (modelId) => {
        const MAX_RETRIES = 3;
        let lastErr;
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
          try {
            return await window.transformers.pipeline(
              'automatic-speech-recognition',
              modelId,
              { progress_callback } // no dtype hint ‚Äî more portable
            );
          } catch (e) {
            lastErr = e;
            console.warn(`Whisper load attempt ${attempt} failed:`, e);
            // brief backoff
            await new Promise(r => setTimeout(r, 1500 * attempt));
          }
        }
        throw lastErr;
      };

      try {
        // 1) Always make sure tiny works first (fastest path).
        asr = await loadPipeline(WHISPER_FAST);
        whisperReady = true;
        setWhisperBadge('STT: Whisper (ready)', true);
        speak('Whisper model ready.');

        // 2) Try to warm up base in the background for better accuracy (optional).
        //    If this fails (CDN blocked, etc.), we silently keep tiny.
        loadPipeline(WHISPER_QUALITY)
          .then(p => {
            asr = p;
            setWhisperBadge('STT: Whisper (base ready)', true);
          })
          .catch(err => {
            console.warn('Background upgrade to base failed; staying on tiny.', err);
          });

      } catch (err) {
        console.error('Whisper failed to load:', err);
        whisperReady = false;
        setWhisperBadge('STT: Browser (fallback)', false);
        speak('I could not load the Whisper model here, so I will use the browser recognizer.');
        // Switch the UI back to Browser STT
        mode = 'web';
        modeWebBtn.classList.add('active');
        modeWhisperBtn.classList.remove('active');
      }
    }

    async function startWhisper() {
      await ensureWhisper();
      if (!whisperReady) return;

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      chunks = [];
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });

      mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };

      mediaRecorder.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        try {
          setWhisperBadge('STT: Whisper (transcribing‚Ä¶)');
          const result = await asr(blob, { chunk_length_s: 30, return_timestamps: false });
          const text = (result?.text || '').trim();
          setWhisperBadge('STT: Whisper (ready)', true);
          you.textContent = text;
          handleUtterance(text);
        } catch (err) {
          console.error('Transcription error:', err);
          setWhisperBadge('STT: Whisper (error)', false);
          speak('Sorry, I could not transcribe that. Please try again.');
        }
      };

      mediaRecorder.start();

      // Auto-stop after ~6s so the user doesn‚Äôt have to click "Stop".
      setTimeout(() => {
        try {
          if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
        } catch {}
      }, 6000);
    }

    function stopWhisper() {
      try { mediaRecorder && mediaRecorder.state === 'recording' && mediaRecorder.stop(); } catch {}
      try { mediaStream && mediaStream.getTracks().forEach(t => t.stop()); } catch {}
    }
    </script>


    // ===== SECTION: MODE TOGGLE & MIC BUTTON =================================
    modeWebBtn.onclick = ()=>{
      mode='web';
      modeWebBtn.classList.add('active'); modeWhisperBtn.classList.remove('active');
      modelHint.innerHTML='Mode: <b>Browser STT</b> (fast). Switch to <b>Whisper STT</b> for better accuracy.';
      setWhisperBadge('STT: Browser'); 
    };
    modeWhisperBtn.onclick = ()=>{
      mode='whisper';
      modeWhisperBtn.classList.add('active'); modeWebBtn.classList.remove('active');
      modelHint.innerHTML='Mode: <b>Whisper STT</b>. First run downloads a small model; accuracy is better for SD-WAN/SASE.';
      setWhisperBadge('STT: Whisper (loading‚Ä¶)'); ensureWhisper();
    };

    toggleBtn.onclick = async ()=>{
      if (!listening){
        listening = true;
        toggleBtn.textContent='Stop Listening'; toggleBtn.classList.add('stop');
        live.textContent='Mic: listening‚Ä¶'; live.classList.remove('offline'); live.classList.add('online');
        if (mode==='web'){ rec && rec.start(); } else { await startWhisper(); }
      } else {
        listening = false;
        toggleBtn.textContent='Start Listening'; toggleBtn.classList.remove('stop');
        live.textContent='Mic: idle'; live.classList.add('offline'); live.classList.remove('online');
        if (mode==='web'){ rec && rec.stop(); } else { stopWhisper(); }
      }
    };

    // ===== SECTION: INIT ======================================================
    loadProducts();
  </script>
</body>
</html>
